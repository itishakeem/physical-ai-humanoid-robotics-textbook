"use strict";(globalThis.webpackChunkmy_book=globalThis.webpackChunkmy_book||[]).push([[4892],{2777:(r,n,e)=>{e.r(n),e.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>a,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"chapter4/diagrams","title":"Chapter 4: Control Systems - Diagrams / Illustrations","description":"Control System Architecture Flowchart","source":"@site/docs/chapter4/diagrams.md","sourceDirName":"chapter4","slug":"/chapter4/diagrams","permalink":"/physical-ai-humanoid-robotics-textbook/docs/chapter4/diagrams","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/chapter4/diagrams.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 4: Control Systems - Practical Examples","permalink":"/physical-ai-humanoid-robotics-textbook/docs/chapter4/practical_examples"},"next":{"title":"Chapter 5: AI Integration in Humanoids","permalink":"/physical-ai-humanoid-robotics-textbook/docs/chapter5/summary"}}');var t=e(4848),i=e(8453);const a={},s="Chapter 4: Control Systems - Diagrams / Illustrations",l={},c=[{value:"Control System Architecture Flowchart",id:"control-system-architecture-flowchart",level:2},{value:"PID Controller Visualization",id:"pid-controller-visualization",level:2},{value:"Inverse Kinematics: 2-Link Arm Example",id:"inverse-kinematics-2-link-arm-example",level:2},{value:"Whole-Body Control Optimization",id:"whole-body-control-optimization",level:2},{value:"Kalman Filter for State Estimation",id:"kalman-filter-for-state-estimation",level:2}];function m(r){const n={code:"code",h1:"h1",h2:"h2",header:"header",hr:"hr",p:"p",pre:"pre",...(0,i.R)(),...r.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"chapter-4-control-systems---diagrams--illustrations",children:"Chapter 4: Control Systems - Diagrams / Illustrations"})}),"\n",(0,t.jsx)(n.h2,{id:"control-system-architecture-flowchart",children:"Control System Architecture Flowchart"}),"\n",(0,t.jsx)(n.p,{children:"This diagram shows the hierarchical control architecture of a typical humanoid robot."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:'\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502                    TASK PLANNING LAYER (10 Hz)                \u2502\r\n\u2502              High-Level Behavior / Strategic Decision          \u2502\r\n\u2502                   \u2022 "Walk to target location"                  \u2502\r\n\u2502                   \u2022 "Pick up object"                           \u2502\r\n\u2502                   \u2022 "Navigate around obstacle"                 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n                              \u2193\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502              TRAJECTORY PLANNING LAYER (100 Hz)               \u2502\r\n\u2502     Medium-Level Task Decomposition & Path Planning           \u2502\r\n\u2502                                                               \u2502\r\n\u2502  Input: High-level task (e.g., "pick up object")            \u2502\r\n\u2502  Process:                                                     \u2502\r\n\u2502    1. Identify object location using vision                  \u2502\r\n\u2502    2. Plan arm trajectory (inverse kinematics)               \u2502\r\n\u2502    3. Plan footstep sequence (gait generation)               \u2502\r\n\u2502    4. Coordinate multi-body motion                           \u2502\r\n\u2502  Output: Desired joint positions + velocities over time      \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n                              \u2193\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502         WHOLE-BODY CONTROL LAYER (200 Hz, ~5 ms)             \u2502\r\n\u2502        Unified Optimization of All Degrees of Freedom        \u2502\r\n\u2502                                                               \u2502\r\n\u2502  Solve Quadratic Program (QP):                                \u2502\r\n\u2502  \u2022 Objective: Track desired trajectory                        \u2502\r\n\u2502  \u2022 Constraints: Physics, friction, joint limits              \u2502\r\n\u2502  \u2022 Output: Desired joint accelerations/torques               \u2502\r\n\u2502                                                               \u2502\r\n\u2502  Handles conflicts intelligently:                             \u2502\r\n\u2502  \u2022 Must maintain balance (highest priority)                   \u2502\r\n\u2502  \u2022 Then track arm motion (secondary)                          \u2502\r\n\u2502  \u2022 Then achieve efficiency (tertiary)                         \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n                              \u2193\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502        JOINT-LEVEL SERVO CONTROL (1000 Hz, 1 ms)             \u2502\r\n\u2502  Low-Level Motor Control via Feedback Loops (PID/State FB)   \u2502\r\n\u2502                                                               \u2502\r\n\u2502  For each of N joints:                                        \u2502\r\n\u2502    1. Read joint encoder (current position)                   \u2502\r\n\u2502    2. Compute error vs. target position                       \u2502\r\n\u2502    3. Apply PID: u = Kp*e + Ki*\u222be + Kd*de/dt              \u2502\r\n\u2502    4. Send command to motor driver                            \u2502\r\n\u2502    5. Motor rotates, changing joint angle                     \u2502\r\n\u2502                                                               \u2502\r\n\u2502  Result: Smooth, damped approach to target angle              \u2502\r\n\u2502  Handles disturbances in real-time                            \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n                              \u2193\r\n                      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n                      \u2502   ACTUATORS  \u2502\r\n                      \u2502              \u2502\r\n                      \u2502  \u2022 Motors    \u2502\r\n                      \u2502  \u2022 Hydraulics\u2502\r\n                      \u2502  \u2022 Solenoids \u2502\r\n                      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n                              \u2193\r\n                      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n                      \u2502    ROBOT     \u2502\r\n                      \u2502   MECHANICS  \u2502\r\n                      \u2502              \u2502\r\n                      \u2502  Joints move \u2502\r\n                      \u2502  Body motion \u2502\r\n                      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n                              \u2193\r\n                      \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n                      \u2502   SENSORS    \u2502\r\n                      \u2502              \u2502\r\n                      \u2502  \u2022 Encoders  \u2502\r\n                      \u2502  \u2022 IMU       \u2502\r\n                      \u2502  \u2022 F/T Sensor\u2502\r\n                      \u2502  \u2022 Cameras   \u2502\r\n                      \u2502  \u2022 LiDAR     \u2502\r\n                      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n                              \u2193\r\n                        [FEEDBACK LOOPS]\r\n                        \u2191             \u2191\r\n                        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\nLegend:\r\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\r\n\u2500\u2192 Information flow (feedforward)\r\n\u2191 Measurement feedback\r\nEach layer processes information at different frequency (faster at lower layers)\r\nTypical latency per layer: ~5-10 ms\r\nTotal system latency: ~30-50 ms (acceptable for bipedal balance)\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"pid-controller-visualization",children:"PID Controller Visualization"}),"\n",(0,t.jsx)(n.p,{children:"This diagram illustrates the three components of a PID controller and their effects."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"              JOINT ANGLE CONTROL EXAMPLE\r\n    Target: 30\xb0    Actual: 25\xb0    Error: 5\xb0\r\n\r\nTime Evolution of Control Response:\r\n\r\n        Angle (\xb0)\r\n           40 \u2524\r\n              \u2502                \u256d\u2500 No overshoot (ideal)\r\n              \u2502\r\n           30 \u2524        \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u256d\u2500  Target\r\n              \u2502       \u2571\u2571\r\n              \u2502      \u2571\u2571 \u2190 Proportional term dominates\r\n              \u2502     \u2571  \r\n           20 \u2524    \u2571\r\n              \u2502   \u2571\r\n              \u2502  \u2571\r\n           10 \u2524 \u2571\r\n              \u2502\u2571\r\n            0 \u251c\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\u2534\r\n              0   0.2  0.4  0.6  0.8  Time (s)\r\n\r\n\r\nComponent Contributions Over Time:\r\n\r\nTime: 0.0 s\r\n  Error: 5\xb0\r\n  \u251c\u2500 Proportional (Kp=50):  5 * 50 = 250  \u2190 Large immediate response\r\n  \u251c\u2500 Integral (Ki=5):       0.0         \u2190 No integral yet\r\n  \u251c\u2500 Derivative (Kd=10):    0.0         \u2190 No rate change yet\r\n  \u2514\u2500 Total Command: 250\r\n\r\nTime: 0.1 s\r\n  Error: 3\xb0\r\n  \u251c\u2500 Proportional (Kp=50):  3 * 50 = 150  \u2190 Reduced as error shrinks\r\n  \u251c\u2500 Integral (Ki=5):       0.3 * 5 = 1.5 \u2190 Accumulating\r\n  \u251c\u2500 Derivative (Kd=10):    -20 * 10 = -200 \u2190 Damping: error changing at -20\xb0/s\r\n  \u2514\u2500 Total Command: 150 + 1.5 - 200 = -48.5 (slight deceleration)\r\n\r\nTime: 0.2 s\r\n  Error: 1\xb0\r\n  \u251c\u2500 Proportional (Kp=50):  1 * 50 = 50    \u2190 Small correction\r\n  \u251c\u2500 Integral (Ki=5):       0.8 * 5 = 4.0  \u2190 More accumulated\r\n  \u251c\u2500 Derivative (Kd=10):    -5 * 10 = -50  \u2190 Preventing overshoot\r\n  \u2514\u2500 Total Command: 50 + 4 - 50 = 4 (fine-tuning)\r\n\r\nTime: 0.4 s\r\n  Error: 0\xb0 (reached target)\r\n  \u251c\u2500 Proportional (Kp=50):  0 * 50 = 0\r\n  \u251c\u2500 Integral (Ki=5):       2.0 * 5 = 10    \u2190 Integral tail (very small)\r\n  \u251c\u2500 Derivative (Kd=10):    0 * 10 = 0\r\n  \u2514\u2500 Total Command: 10 (slight offset to maintain position)\r\n\r\n\r\nEFFECT OF TUNING PARAMETERS:\r\n\r\nHigh Kp (e.g., 100):          Medium Kp (e.g., 50):         Low Kp (e.g., 20):\r\n  \u2502                             \u2502                             \u2502\r\n  \u2502    \u256d\u2500\u2500\u2500                      \u2502  \u2571\u2500                         \u2502     \u2571\u2500\u2500\u2500\r\n  \u2502   \u2571                          \u2502 \u2571                           \u2502    \u2571\r\n  \u2502 \u2571  Overshoot!               \u2502\u2571  Smooth                     \u2502___\u2571 Slow!\r\n  \u2502\u2571   Oscillations             Target reached smoothly        Takes 2 seconds\r\n  \u2514                              \u2514                             \u2514\r\n\r\n\r\nHigh Kd (damping):            Medium Kd:                    Low Kd:\r\n  \u2502   Smooth, slow              \u2502  Balanced                    \u2502  Oscillatory\r\n  \u2502\u2500\u2500\u2500\u2500                         \u2502 \u2571\u2500\u2500\u2500                         \u2502  \u256d\u2500\u2500\u256e \u256d\u2500\u2500\u256e\r\n  \u2502   Overdamped                \u2502\u2571     No overshoot            \u2502 \u2571    \u2572\u2571    \u2572\r\n  \u2514                             \u2514                             \u2514\r\n\r\n\r\nPID Gain Selection (Typical Values for Joint Control):\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 Joint Type        \u2502 Kp    \u2502 Ki   \u2502 Kd     \u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502 Heavy (hip/knee)  \u2502 50-100\u2502 2-5  \u2502 5-15   \u2502\r\n\u2502 Light (wrist)     \u2502 20-50 \u2502 1-2  \u2502 2-5    \u2502\r\n\u2502 Tool tip          \u2502 10-30 \u2502 0.5-1\u2502 1-3    \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"inverse-kinematics-2-link-arm-example",children:"Inverse Kinematics: 2-Link Arm Example"}),"\n",(0,t.jsx)(n.p,{children:"This diagram shows how inverse kinematics solves for joint angles from desired position."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"                    FORWARD KINEMATICS\r\n                    (Position given angles)\r\n\r\n                         Joint 2 (\u03b8\u2082)\r\n                         \u2571\u2571\u2571\u2571\u2571\u2571\r\n                        \u2571 L\u2082 \u2571\r\n                       \u2571    \u2571\r\n                      \u2571\u2500\u2500\u2500\u2500\u2571 \u2192 End-Effector (x, y)\r\n                     \u2571\r\n                    \u2571 Joint 1 (\u03b8\u2081)\r\n                   \u2571\r\n                  \u251c\u2500\u2500\u2500 L\u2081 \u2500\u2500\u2500\u2500\r\n                  \u2502\r\n                  O (Base)\r\n\r\nFormula:\r\nx = L\u2081\xb7cos(\u03b8\u2081) + L\u2082\xb7cos(\u03b8\u2081 + \u03b8\u2082)\r\ny = L\u2081\xb7sin(\u03b8\u2081) + L\u2082\xb7sin(\u03b8\u2081 + \u03b8\u2082)\r\n\r\nGiven: \u03b8\u2081 = 30\xb0, \u03b8\u2082 = 45\xb0, L\u2081 = 1 m, L\u2082 = 0.8 m\r\nCompute:\r\nx = 1\xb7cos(30\xb0) + 0.8\xb7cos(75\xb0)  = 0.866 + 0.207 = 1.073 m\r\ny = 1\xb7sin(30\xb0) + 0.8\xb7sin(75\xb0)  = 0.5 + 0.773 = 1.273 m\r\n\r\n\r\n                 INVERSE KINEMATICS\r\n              (Angles from desired position)\r\n\r\nProblem: Given desired (x, y), find (\u03b8\u2081, \u03b8\u2082)\r\n\r\nANALYTICAL SOLUTION (closed-form):\r\nFor 2-link arm:\r\n\r\nLaw of cosines: d\xb2 = L\u2081\xb2 + L\u2082\xb2 - 2\xb7L\u2081\xb7L\u2082\xb7cos(\u03c0 - \u03b8\u2082)\r\n              where d = \u221a(x\xb2 + y\xb2)\r\n\r\n\u03b8\u2082 = acos((x\xb2 + y\xb2 - L\u2081\xb2 - L\u2082\xb2) / (2\xb7L\u2081\xb7L\u2082))\r\n\u03b8\u2081 = atan2(y, x) - atan2(L\u2082\xb7sin(\u03b8\u2082), L\u2081 + L\u2082\xb7cos(\u03b8\u2082))\r\n\r\nGiven: desired (x, y) = (1.5, 1.0) m, L\u2081 = 1 m, L\u2082 = 0.8 m\r\n\r\nStep 1: Calculate distance\r\nd = \u221a(1.5\xb2 + 1.0\xb2) = \u221a(2.25 + 1.0) = 1.806 m\r\n\r\nStep 2: Calculate \u03b8\u2082\r\n\u03b8\u2082 = acos((2.25 + 1.0 - 1.0 - 0.64) / (2\xb71\xb70.8))\r\n   = acos(1.61 / 1.6)\r\n   = acos(1.006) \u2192 IMPOSSIBLE!\r\n\r\nInterpretation: End-effector is out of reach (too far)\r\nMaximum reach: L\u2081 + L\u2082 = 1.8 m\r\nDesired distance: 1.806 m < 1.8 m \u2192 Just barely reachable\r\n\r\nModified desired position: (1.4, 0.8) m\r\n\r\nStep 1 (revised): Calculate distance\r\nd = \u221a(1.4\xb2 + 0.8\xb2) = \u221a(2.96) = 1.72 m\r\n\r\nStep 2: Calculate \u03b8\u2082\r\n\u03b8\u2082 = acos((1.96 + 0.64 - 1.0 - 0.64) / 1.6)\r\n   = acos(0.96) = 16.26\xb0\r\n\r\nStep 3: Calculate \u03b8\u2081\r\n\u03b8\u2081 = atan2(0.8, 1.4) - atan2(0.8\xb7sin(16.26\xb0), 1.0 + 0.8\xb7cos(16.26\xb0))\r\n   = 29.74\xb0 - atan2(0.225, 1.765)\r\n   = 29.74\xb0 - 7.25\xb0 = 22.49\xb0\r\n\r\nSOLUTION: \u03b8\u2081 = 22.49\xb0, \u03b8\u2082 = 16.26\xb0\r\n\r\n\r\nMULTIPLE SOLUTIONS (Redundancy):\r\n\r\n2-link arm has exactly 2 solutions for most positions (elbow-up and elbow-down):\r\n\r\nTarget (x, y)\r\n     \u2193\r\n    \u2571 \u2190 Elbow-Up Solution: \u03b8\u2081 = 22.49\xb0, \u03b8\u2082 = 16.26\xb0\r\n   \u2571\r\n  \u251c\u2500\u2500\u2500\u2500\u2500\r\n  \r\n  \r\n  \r\n  \u2514\u2500\r\n   \u2572 \u2190 Elbow-Down Solution: \u03b8\u2081 = -17.51\xb0, \u03b8\u2082 = -156.26\xb0\r\n\r\n\r\n7-DOF HUMANOID ARM: Infinite Solutions!\r\n\r\n7 degrees of freedom, 3 spatial coordinates to reach (x, y, z)\r\n7 - 3 = 4 dimensional null-space of solutions\r\n\r\nControl system selects best solution by:\r\n1. Minimizing energy (prefer configurations requiring less torque)\r\n2. Avoiding obstacles (prefer paths clear of collision)\r\n3. Maintaining balance (prefer movements that don't destabilize robot)\r\n4. Maximizing manipulability (prefer configurations with good dexterity)\r\n\r\nMost common approach: Jacobian-based optimization\r\n\u03b8_solution = argmin || J(\u03b8)\xb7d\u03b8 - dx || + \u03bb\xb7||d\u03b8||\xb2\r\nwhere \u03bb is regularization weight favoring smaller joint movements\r\n\r\n\r\nCONVERGENCE OF ITERATIVE IK SOLVER:\r\n\r\nIteration 0:\r\nCurrent pose: \u03b8 = [0\xb0, 0\xb0, 0\xb0, 0\xb0, 0\xb0, 0\xb0, 0\xb0]\r\nEnd-effector position: (0.5, 0, 2.0) m\r\nTarget position: (1.4, 0.8, 1.5) m\r\nError: 1.3 m\r\n\r\nIteration 1:\r\nCompute Jacobian J (7\xd73 matrix)\r\nCalculate: d\u03b8 = \u03b1\xb7J\u207a\xb7(target - current)  [where J\u207a is pseudoinverse]\r\nNew angles: \u03b8 \u2190 \u03b8 + d\u03b8\r\nEnd-effector position: (0.8, 0.3, 1.7) m\r\nError: 0.8 m\r\n\r\nIteration 2:\r\nEnd-effector position: (1.1, 0.55, 1.6) m\r\nError: 0.4 m\r\n\r\nIteration 3:\r\nEnd-effector position: (1.3, 0.75, 1.5) m\r\nError: 0.15 m\r\n\r\nIteration 4:\r\nEnd-effector position: (1.39, 0.79, 1.5) m\r\nError: 0.02 m (converged!)\r\n\r\nConvergence time: ~50 ms for 7-DOF arm\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"whole-body-control-optimization",children:"Whole-Body Control Optimization"}),"\n",(0,t.jsx)(n.p,{children:"This diagram shows how whole-body control balances competing objectives."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"WHOLE-BODY CONTROL PROBLEM FORMULATION:\r\n\r\nAt each time-step, solve:\r\n\r\nMinimize: ||a - a_desired||\xb2_Q + ||\u03c4||\xb2_R\r\n\r\nSubject to:\r\n  M(q)\xb7a + C(q,v)\xb7v + G(q) = \u03c4                    [Dynamics constraint]\r\n  f_L + f_R = m\xb7g + m\xb7a_CoM                       [CoM acceleration]\r\n  |f| < \u03bc\xb7|f_N|  (friction cone)                  [No slipping]\r\n  -\u03c4_max \u2264 \u03c4 \u2264 \u03c4_max                             [Torque limits]\r\n  -\u03b8_max \u2264 \u03b8 \u2264 \u03b8_max                             [Joint limits]\r\n  ZMP \u2208 Support Polygon \xb1 margin                  [Balance]\r\n  x_hand = target + tracking_error                [Reaching objective]\r\n\r\nVariables to solve for:\r\n  q  = joint positions (7 per leg + 3 per arm + 3 torso = 40 DoF)\r\n  v  = joint velocities\r\n  a  = joint accelerations        \u2190 Primary output\r\n  \u03c4  = joint torques\r\n  f_L, f_R = ground reaction forces (left and right foot)\r\n\r\n\r\nEXAMPLE: WALKING WHILE REACHING\r\n\r\nRobot state:\r\n  \u2022 Standing on both feet\r\n  \u2022 Task 1: Walk forward at 1 m/s (locomotion objective)\r\n  \u2022 Task 2: Move left arm to reach shelf at (1.5m, 0.5m, 1.5m)\r\n  \u2022 Constraint: Don't fall (maintain balance)\r\n\r\nConflicting objectives:\r\n  \u2022 Walking requires center-of-mass acceleration\r\n  \u2022 Reaching requires arm acceleration\r\n  \u2022 Both can't happen simultaneously without destabilizing\r\n\r\nSolution found by QP optimization:\r\n\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 PRIORITY 1: Balance (hard constraint)\u2502\r\n\u2502 ZMP must stay in support polygon    \u2502\r\n\u2502                                     \u2502\r\n\u2502 Margin: 5 cm from edge              \u2502\r\n\u2502 Non-negotiable: safety              \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n                 \u2193\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 PRIORITY 2: Locomotion              \u2502\r\n\u2502 Achieve forward walking at 1 m/s    \u2502\r\n\u2502                                     \u2502\r\n\u2502 Allocate 70% of leg torque budget   \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n                 \u2193\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 PRIORITY 3: Reaching                \u2502\r\n\u2502 Move arm toward target shelf        \u2502\r\n\u2502                                     \u2502\r\n\u2502 Remaining arm/torso torque budget   \u2502\r\n\u2502 Reach velocity reduced to 0.5 m/s   \u2502\r\n\u2502 (instead of requested 1.0 m/s)      \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\nResult: Robot walks forward while slowly reaching for shelf\r\n        If balance threatened, reaching stops (arm holds position)\r\n\r\n\r\nCOMPUTATIONAL COMPLEXITY:\r\n\r\nProblem size:\r\n  \u2022 40 decision variables (joint accelerations)\r\n  \u2022 50+ constraints\r\n  \u2022 Real-time deadline: 5 ms\r\n\r\nSolution method: Quadratic Programming (QP)\r\n  \u2022 Algorithms: Interior Point, Active Set\r\n  \u2022 Libraries: qpOASES, SCS\r\n  \u2022 Typical solve time: 2-4 ms (room for margin)\r\n  \u2022 Total loop time: 5 ms\r\n    - Read sensors: 1 ms\r\n    - Solve QP: 3 ms\r\n    - Send commands: 1 ms\r\n\r\nFallback: If solve takes >5 ms\r\n  \u2022 Use warm-start with previous solution\r\n  \u2022 Reduces solve time to &lt;2 ms\r\n  \u2022 Slightly suboptimal but still stable\n"})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h2,{id:"kalman-filter-for-state-estimation",children:"Kalman Filter for State Estimation"}),"\n",(0,t.jsx)(n.p,{children:"This diagram shows how Kalman filtering optimally combines sensor data."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"KALMAN FILTER: RECURSIVE OPTIMAL STATE ESTIMATION\r\n\r\nProblem: Estimate robot's full state from noisy sensors\r\n\r\nExample: Estimate bipedal robot's Center of Mass (CoM) position\r\n\r\nSensors available:\r\n  \u2022 IMU: Accelerometers measure acceleration (noisy: \u03c3_a = 0.5 m/s\xb2)\r\n  \u2022 Force sensors: Two force plates measure weight distribution\r\n  \u2022 Encoders: Joint angles (highly accurate: \u03c3_\u03b8 = 0.1\xb0)\r\n\r\nSTATE VECTOR: x = [CoM_position, CoM_velocity]\r\n\r\nPREDICTION PHASE (using motion model):\r\n\r\nTime t-1:\r\n  x\u0302(t-1) = [1.2 m, 0.8 m/s]  (estimated CoM position and velocity)\r\n\r\nFrom t-1 to t (\u0394t = 10 ms):\r\n  Using kinematics: x(t) = x(t-1) + v(t-1)\xb7\u0394t\r\n  Prediction: x\u0302_pred(t) = [1.2 + 0.8\xb70.01, 0.8] = [1.208 m, 0.8 m/s]\r\n  Prediction covariance: P_pred(t) = P(t-1) + Q\r\n    where Q is process noise (model has uncertainty)\r\n\r\nMEASUREMENT PHASE:\r\n\r\nSensors now report:\r\n  \u2022 Accelerometer: a_meas = 0.5 m/s\xb2 (goal was 0, so CoM is accelerating)\r\n  \u2022 Force sensors: CoM moving forward (not useful for position directly)\r\n  \u2022 Encoders: Joint angles indicate calculated CoM should be at 1.21 m\r\n\r\nFUSION:\r\n\r\nInnovation (predicted - measured):\r\n  \u0394x = x\u0302_pred - x_meas = [1.208 - 1.21, 0.8 - 0.50] = [-0.002, 0.30]\r\n\r\nKalman Gain (how much to trust measurements vs. prediction):\r\n  K = P_pred \xb7 (P_pred + R)\u207b\xb9\r\n  where R is measurement noise covariance\r\n\r\nIf R (measurement noise) is large:\r\n  K is small \u2192 trust prediction more than measurement\r\n\r\nIf R is small (high-confidence sensors):\r\n  K is large \u2192 trust measurement more than prediction\r\n\r\nFused estimate:\r\n  x\u0302(t) = x\u0302_pred + K\xb7\u0394x\r\n  x\u0302(t) = [1.208, 0.8] + K\xb7[-0.002, 0.30]\r\n\r\nTypical K values:\r\n  K = [0.7, 0.5]\r\n\r\nResult:\r\n  x\u0302(t) = [1.208 + 0.7\xb7(-0.002), 0.8 + 0.5\xb70.30]\r\n       = [1.206 m, 0.95 m/s]\r\n\r\nUpdated covariance:\r\n  P(t) = (I - K\xb7H)\xb7P_pred\r\n  Result: Uncertainty reduced (we now have more information)\r\n\r\n\r\nCOMPARISON: KALMAN FILTER vs. SIMPLE AVERAGE\r\n\r\nSingle measurement (no Kalman):\r\n  CoM position = (1.208 + 1.21)/2 = 1.209 m\r\n  No velocity estimate\r\n  Still uncertain about acceleration\r\n\r\nWith Kalman filter:\r\n  CoM position = 1.206 m (accounts for prediction model)\r\n  CoM velocity = 0.95 m/s (estimated from acceleration)\r\n  Uncertainty quantified (know we're 68% confident within \xb10.05 m)\r\n  Smooth trajectory (filter removes measurement noise)\r\n\r\n\r\nPRACTICAL BENEFIT: BALANCE CONTROL\r\n\r\nHumanoid robot balance relies on accurate CoM estimation:\r\n\r\nWithout Kalman filter:\r\n  \u2022 Sensor noise directly affects control commands\r\n  \u2022 Robot over-corrects, creating oscillations\r\n  \u2022 Unnatural, jerky movements\r\n\r\nWith Kalman filter:\r\n  \u2022 Noise filtered out\r\n  \u2022 Control responds smoothly to real motion\r\n  \u2022 Natural-appearing, stable walking\r\n\r\nResult: Difference between jerky robot and smooth biped.\n"})})]})}function d(r={}){const{wrapper:n}={...(0,i.R)(),...r.components};return n?(0,t.jsx)(n,{...r,children:(0,t.jsx)(m,{...r})}):m(r)}},8453:(r,n,e)=>{e.d(n,{R:()=>a,x:()=>s});var o=e(6540);const t={},i=o.createContext(t);function a(r){const n=o.useContext(i);return o.useMemo(function(){return"function"==typeof r?r(n):{...n,...r}},[n,r])}function s(r){let n;return n=r.disableParentContext?"function"==typeof r.components?r.components(t):r.components||t:a(r.components),o.createElement(i.Provider,{value:n},r.children)}}}]);