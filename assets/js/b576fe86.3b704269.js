"use strict";(globalThis.webpackChunkmy_book=globalThis.webpackChunkmy_book||[]).push([[5062],{7966:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>a,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"chapter6/key_concepts","title":"Chapter 6: Motion and Navigation - Key Concepts","description":"Path Planning Algorithms","source":"@site/docs/chapter6/key_concepts.md","sourceDirName":"chapter6","slug":"/chapter6/key_concepts","permalink":"/docs/chapter6/key_concepts","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/chapter6/key_concepts.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 6: Motion and Navigation","permalink":"/docs/chapter6/summary"},"next":{"title":"Chapter 6: Motion and Navigation - Practical Examples","permalink":"/docs/chapter6/practical_examples"}}');var s=i(4848),t=i(8453);const o={},l="Chapter 6: Motion and Navigation - Key Concepts",a={},c=[{value:"Path Planning Algorithms",id:"path-planning-algorithms",level:2},{value:"Graph-Based Planning (Dijkstra, A*)",id:"graph-based-planning-dijkstra-a",level:3},{value:"Sample-Based Planning (RRT, PRM)",id:"sample-based-planning-rrt-prm",level:3},{value:"Probabilistic Roadmap (PRM)",id:"probabilistic-roadmap-prm",level:3},{value:"Motion Planning for Humanoid Locomotion",id:"motion-planning-for-humanoid-locomotion",level:2},{value:"Gait Generation",id:"gait-generation",level:3},{value:"Trajectory Optimization",id:"trajectory-optimization",level:3},{value:"Center of Pressure (CoP) and Zero Moment Point (ZMP) Control",id:"center-of-pressure-cop-and-zero-moment-point-zmp-control",level:3},{value:"Obstacle Avoidance",id:"obstacle-avoidance",level:2},{value:"Vector Field Histogram (VFH)",id:"vector-field-histogram-vfh",level:3},{value:"Dynamic Window Approach (DWA)",id:"dynamic-window-approach-dwa",level:3},{value:"Potential Field Methods",id:"potential-field-methods",level:3},{value:"SLAM (Simultaneous Localization and Mapping)",id:"slam-simultaneous-localization-and-mapping",level:2},{value:"Visual SLAM (ORB-SLAM)",id:"visual-slam-orb-slam",level:3},{value:"LiDAR SLAM (ICP and Graph SLAM)",id:"lidar-slam-icp-and-graph-slam",level:3},{value:"Real-Time Adaptive Motion",id:"real-time-adaptive-motion",level:2},{value:"Replanning During Execution",id:"replanning-during-execution",level:3},{value:"Energy-Efficient Locomotion",id:"energy-efficient-locomotion",level:3}];function d(n){const e={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"chapter-6-motion-and-navigation---key-concepts",children:"Chapter 6: Motion and Navigation - Key Concepts"})}),"\n",(0,s.jsx)(e.h2,{id:"path-planning-algorithms",children:"Path Planning Algorithms"}),"\n",(0,s.jsx)(e.p,{children:"Path planning computes collision-free routes from start to goal locations."}),"\n",(0,s.jsx)(e.h3,{id:"graph-based-planning-dijkstra-a",children:"Graph-Based Planning (Dijkstra, A*)"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Discretization"}),": Convert continuous environment to graph"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Occupy grid: Divide space into cells (e.g., 10 cm \xd7 10 cm)"}),"\n",(0,s.jsx)(e.li,{children:"Nodes: Grid cells"}),"\n",(0,s.jsx)(e.li,{children:"Edges: Connections between adjacent cells"}),"\n",(0,s.jsx)(e.li,{children:"Cell types: Free (robot can traverse), Occupied (obstacle)"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Dijkstra's Algorithm"}),": Find shortest path"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"Initialize: Cost[start] = 0, Cost[all others] = \u221e\r\nVisited = {}\r\n\r\nLoop:\r\n  Current = unvisited node with lowest cost\r\n  Visited.add(Current)\r\n  \r\n  For each unvisited neighbor N of Current:\r\n    New_cost = Cost[Current] + distance(Current, N)\r\n    If New_cost < Cost[N]:\r\n      Cost[N] = New_cost\r\n      Parent[N] = Current\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Result"}),": Path from start to goal with minimum cost (distance)"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Complexity"}),": O(N\xb2 log N) for N nodes, slow for large environments"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Example"}),": Warehouse with 100m \xd7 100m area, 0.1m grid resolution"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Grid size: 1000 \xd7 1000 = 1,000,000 cells"}),"\n",(0,s.jsx)(e.li,{children:"Dijkstra time: ~1 second (acceptable for planning, not real-time)"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsxs)(e.em,{children:[(0,s.jsx)(e.em,{children:"A"})," Algorithm"]}),"*: Faster variant using heuristics"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Prioritizes nodes closer to goal"}),"\n",(0,s.jsx)(e.li,{children:"Typical improvement: 10-100\xd7 faster than Dijkstra"}),"\n",(0,s.jsx)(e.li,{children:"Example: Same warehouse, A* time: ~100 ms"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Limitation"}),': Discrete grid leads to "staircase" paths, inefficient for humanoid locomotion']}),"\n",(0,s.jsx)(e.h3,{id:"sample-based-planning-rrt-prm",children:"Sample-Based Planning (RRT, PRM)"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Rapidly-Exploring Random Tree (RRT)"}),":"]}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"Start with root node at start position"}),"\n",(0,s.jsx)(e.li,{children:"Repeatedly: Sample random position, connect tree toward it"}),"\n",(0,s.jsx)(e.li,{children:"Continue until tree reaches goal region"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Pseudocode"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"Tree.add(start)\r\n\r\nFor i = 1 to 10000:\r\n  Random_config = RandomSample()\r\n  Nearest = FindNearest(Tree, Random_config)\r\n  \r\n  New_config = StepToward(Nearest, Random_config, step_size)\r\n  \r\n  If CollisionFree(Nearest, New_config):\r\n    Tree.add(New_config)\r\n    SetParent(New_config, Nearest)\r\n    \r\n    If Distance(New_config, goal) < threshold:\r\n      Return Path(start \u2192 goal)\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Advantages"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Handles high-dimensional spaces (humanoid arm: 7D)"}),"\n",(0,s.jsx)(e.li,{children:"Probabilistically complete (finds solution if one exists)"}),"\n",(0,s.jsx)(e.li,{children:"Fast: Often finds paths in 100-500 ms"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Disadvantages"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Paths are non-optimal (not shortest)"}),"\n",(0,s.jsx)(e.li,{children:"Results vary between runs (randomness)"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Application"}),": Humanoid arm reaching"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"State space: 7-dimensional joint angle space"}),"\n",(0,s.jsx)(e.li,{children:"Goal: Reach object at [1.5m, 0.5m, 1.2m]"}),"\n",(0,s.jsx)(e.li,{children:"RRT finds valid joint configuration in ~200 ms"}),"\n",(0,s.jsx)(e.li,{children:"Path quality: Fine (smooth motion to object)"}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"probabilistic-roadmap-prm",children:"Probabilistic Roadmap (PRM)"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Two-phase approach"}),":"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Phase 1: Learning (offline)"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Sample 10,000-100,000 random configurations"}),"\n",(0,s.jsx)(e.li,{children:"Connect nearby samples if collision-free"}),"\n",(0,s.jsx)(e.li,{children:"Result: Graph of valid configurations"}),"\n"]}),"\n",(0,s.jsx)(e.p,{children:(0,s.jsx)(e.strong,{children:"Phase 2: Query (online)"})}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Connect start and goal to nearest graph nodes"}),"\n",(0,s.jsx)(e.li,{children:"Find shortest path in graph using Dijkstra"}),"\n",(0,s.jsx)(e.li,{children:"Time: Typically <10 ms"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Advantage"}),": Multiple queries share same roadmap; very fast after learning"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Limitation"}),": Must recompute roadmap if environment changes"]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"motion-planning-for-humanoid-locomotion",children:"Motion Planning for Humanoid Locomotion"}),"\n",(0,s.jsx)(e.p,{children:"Walking requires not just path planning but specific joint-angle trajectories."}),"\n",(0,s.jsx)(e.h3,{id:"gait-generation",children:"Gait Generation"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Walking Gait Phases"})," (cycle: ~1 second for normal walking speed)"]}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Heel Strike"})," (0.0-0.2s):"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Left leg makes contact with ground"}),"\n",(0,s.jsx)(e.li,{children:"Right leg pushing off"}),"\n",(0,s.jsx)(e.li,{children:"Transition between legs"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Loading Response"})," (0.0-0.1s):"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Left knee bends to absorb impact"}),"\n",(0,s.jsx)(e.li,{children:"Right leg leaving ground"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Mid-Stance"})," (0.1-0.3s):"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Left foot planted, right leg swinging forward"}),"\n",(0,s.jsx)(e.li,{children:"Body weight transfers over left leg"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Terminal Swing"})," (0.3-0.5s):"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Right leg approaching strike position"}),"\n",(0,s.jsx)(e.li,{children:"Left leg preparing to push off"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Pre-Swing"})," (0.4-0.5s):"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Transition between legs"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Initial Swing"})," (0.5-0.8s):"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Left leg swinging forward"}),"\n",(0,s.jsx)(e.li,{children:"Right leg providing stability"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Mid-Swing"})," (0.8-0.95s):"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Left leg at peak swing height"}),"\n",(0,s.jsx)(e.li,{children:"Right foot supporting full weight"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:["\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Terminal Swing"})," (0.95-1.0s):"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Left leg approaching ground for next heel strike"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"trajectory-optimization",children:"Trajectory Optimization"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Objective"}),": Generate smooth joint trajectories that are stable and efficient"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Formulation"})," (mathematical):"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"Minimize: Energy = \u03a3 \u03c4\xb2\xb7t\r\n\r\nSubject to:\r\n  - Dynamics constraints (physics equations)\r\n  - ZMP within support polygon (balance)\r\n  - Joint limits: -\u03b8_max \u2264 \u03b8 \u2264 \u03b8_max\r\n  - No collision with ground\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Algorithm"}),": Trajectory optimization using nonlinear programming"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Variables: Joint angles over 50-100 time steps"}),"\n",(0,s.jsx)(e.li,{children:"Constraints: 50,000+ (for 100 steps \xd7 50 constraints each)"}),"\n",(0,s.jsx)(e.li,{children:"Solver: Interior point method"}),"\n",(0,s.jsx)(e.li,{children:"Computation time: 1-10 seconds per trajectory (offline planning)"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Result"}),": Optimal walking trajectory that is energy-efficient and stable"]}),"\n",(0,s.jsx)(e.h3,{id:"center-of-pressure-cop-and-zero-moment-point-zmp-control",children:"Center of Pressure (CoP) and Zero Moment Point (ZMP) Control"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Zero Moment Point (ZMP)"}),": Point on ground where total moment equals zero"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Stability Criterion"}),": For bipedal stability, ZMP must be within support polygon (area under feet)"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Control Strategy"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"During double-support (both feet planted):\r\n  ZMP can be anywhere under feet\r\n  \r\nDuring single-support (one foot planted):\r\n  ZMP must be under that foot\r\n  \r\nIf ZMP moves outside support polygon:\r\n  Moment develops\r\n  Robot begins to tip\r\n  Must prevent!\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Feedback Control"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"At each timestep:\r\n  Compute current ZMP position (from force sensors)\r\n  \r\n  If ZMP approaching edge of support:\r\n    Shift body CoM back over stable region\r\n    Or place next foot further ahead\r\n    \r\n  Result: ZMP always stays centered in support\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Example"}),": Robot walking on narrow surface (e.g., balance beam)"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Support polygon: 0.2m wide"}),"\n",(0,s.jsx)(e.li,{children:"Robot must keep ZMP within 0.2m region"}),"\n",(0,s.jsx)(e.li,{children:"Walking speed reduced (need more careful balancing)"}),"\n",(0,s.jsx)(e.li,{children:"Margins reduced to \xb15 cm (high risk)"}),"\n",(0,s.jsx)(e.li,{children:"Failure: If ZMP moves >0.1m from center, robot falls"}),"\n"]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"obstacle-avoidance",children:"Obstacle Avoidance"}),"\n",(0,s.jsx)(e.h3,{id:"vector-field-histogram-vfh",children:"Vector Field Histogram (VFH)"}),"\n",(0,s.jsx)(e.p,{children:"Real-time obstacle avoidance for moving humanoids:"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Input"}),": Robot moving at target velocity; obstacle detected"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Algorithm"}),":"]}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"Quantize world around robot into histogram (e.g., 360 directions, 8 ranges)"}),"\n",(0,s.jsx)(e.li,{children:"For each obstacle, mark obstacles in histogram"}),"\n",(0,s.jsx)(e.li,{children:"Find valley (direction with fewest obstacles)"}),"\n",(0,s.jsx)(e.li,{children:"Steer toward valley"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Advantage"}),": Very fast (computation <10 ms)\r\n",(0,s.jsx)(e.strong,{children:"Limitation"}),": Only reacts to immediate surroundings (local method)"]}),"\n",(0,s.jsx)(e.h3,{id:"dynamic-window-approach-dwa",children:"Dynamic Window Approach (DWA)"}),"\n",(0,s.jsx)(e.p,{children:"More sophisticated real-time method:"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Concept"}),": Simulate robot motions for next few seconds; pick one that reaches goal without collision"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Algorithm"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"Generate candidate motions:\r\n  v \u2208 [v_min, v_max], step 0.1 m/s\r\n  \u03c9 \u2208 [\u03c9_min, \u03c9_max], step 0.1 rad/s\r\n  Total candidates: ~100-200\r\n  \r\nFor each candidate (v, \u03c9):\r\n  Simulate next 1-2 seconds\r\n  Check for collisions\r\n  Compute cost:\r\n    - Distance to goal\r\n    - Distance to nearest obstacle\r\n    - Energy cost\r\n  \r\nSelect: Candidate with lowest cost\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Advantage"}),": Looks ahead; smoother motions than VFH\r\n",(0,s.jsx)(e.strong,{children:"Computation"}),": ~50 ms per decision (5-10 Hz update rate)"]}),"\n",(0,s.jsx)(e.h3,{id:"potential-field-methods",children:"Potential Field Methods"}),"\n",(0,s.jsx)(e.p,{children:"Simple attractive and repulsive forces:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"Force_total = F_attractive_to_goal + F_repulsive_from_obstacles\r\n\r\nF_attractive = k_a \xd7 (goal - robot_pos)        [pulls toward goal]\r\nF_repulsive = k_r \xd7 (1/distance_to_obstacle)   [pushes away]\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Advantage"}),": Intuitive; continuous forces (smooth motion)\r\n",(0,s.jsx)(e.strong,{children:"Disadvantage"}),": Can get stuck in local minima (attractive and repulsive forces cancel)"]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"slam-simultaneous-localization-and-mapping",children:"SLAM (Simultaneous Localization and Mapping)"}),"\n",(0,s.jsx)(e.p,{children:"Autonomous robots must often navigate unknown environments. SLAM addresses this:"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Localization: Where am I?"}),"\n",(0,s.jsx)(e.li,{children:"Mapping: What's around me?"}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"visual-slam-orb-slam",children:"Visual SLAM (ORB-SLAM)"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Features"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Detect distinctive keypoints in images (ORB: Oriented FAST and Rotated BRIEF)"}),"\n",(0,s.jsx)(e.li,{children:"Track features across consecutive frames"}),"\n",(0,s.jsx)(e.li,{children:"Estimate motion from feature correspondences"}),"\n",(0,s.jsx)(e.li,{children:"Triangulate 3D structure"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Pipeline"}),":"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"Frame N:\r\n  Detect features: 500-1000 keypoints\r\n  Extract descriptors: 256-bit binary for each\r\n  Match: Compare with Frame N-1\r\n  \r\nFrame N-1 features matched to Frame N:\r\n  \u251c\u2500 400 features successfully matched\r\n  \u2514\u2500 Outliers: 20 spurious matches (RANSAC rejects)\r\n  \r\nCompute motion:\r\n  Essential matrix from feature correspondences\r\n  SVD decomposition\r\n  Result: Rotation + Translation (camera moved 0.3m forward, rotated 5\xb0)\r\n  \r\nTriangulate:\r\n  Use matched features + camera motion\r\n  Compute 3D positions of matched features\r\n  Add to map: 400 new 3D points\r\n  \r\nMap size after 100 frames:\r\n  \u251c\u2500 3D keyframe poses: 100\r\n  \u251c\u2500 3D map points: 40,000\r\n  \u2514\u2500 Computational load: Growing (need optimization)\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Loop Closure"}),": When robot revisits known location"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Detect: Features match previously seen location"}),"\n",(0,s.jsx)(e.li,{children:"Action: Correct accumulated drift in estimates"}),"\n",(0,s.jsx)(e.li,{children:"Effect: Dramatically improves map accuracy"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Accuracy"}),": 1-5% error (good for indoor environments)\r\n",(0,s.jsx)(e.strong,{children:"Computational cost"}),": ~50 ms per frame on modern CPU"]}),"\n",(0,s.jsx)(e.h3,{id:"lidar-slam-icp-and-graph-slam",children:"LiDAR SLAM (ICP and Graph SLAM)"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Process"}),":"]}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"Scan environment with 2D or 3D LiDAR"}),"\n",(0,s.jsx)(e.li,{children:"Match current scan to previous scans"}),"\n",(0,s.jsx)(e.li,{children:"Estimate motion from scan matching"}),"\n",(0,s.jsx)(e.li,{children:"Optimize global map"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Iterative Closest Point (ICP)"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Align two point clouds"}),"\n",(0,s.jsx)(e.li,{children:"Find point correspondences (nearest neighbor)"}),"\n",(0,s.jsx)(e.li,{children:"Compute optimal alignment minimizing distance"}),"\n",(0,s.jsx)(e.li,{children:"Iterate until convergence"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Graph-Based Optimization"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Each scan pose = node in graph"}),"\n",(0,s.jsx)(e.li,{children:"Scan-to-scan matches = edges"}),"\n",(0,s.jsx)(e.li,{children:"Optimize all poses simultaneously to minimize error"}),"\n",(0,s.jsx)(e.li,{children:"Handles loop closure naturally"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Accuracy"}),": 0.1-1% error (very accurate)\r\n",(0,s.jsx)(e.strong,{children:"Computational cost"}),": 100-500 ms per scan (more than visual SLAM, more robust)"]}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"real-time-adaptive-motion",children:"Real-Time Adaptive Motion"}),"\n",(0,s.jsx)(e.h3,{id:"replanning-during-execution",children:"Replanning During Execution"}),"\n",(0,s.jsx)(e.p,{children:"Humanoids often replan during locomotion:"}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Trigger for replanning"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"New obstacle detected (human walked into path)"}),"\n",(0,s.jsx)(e.li,{children:"Goal location changed"}),"\n",(0,s.jsx)(e.li,{children:"Computational resources available"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Fast replanning algorithms"}),":"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsxs)(e.em,{children:[(0,s.jsx)(e.em,{children:"D"})," Lite"]}),"*: Update previous plan locally (~10 ms)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Theta"}),"*: Anytime algorithm (produce better paths if time available)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"RRT"}),"*: Incremental planning (improve path quality over time)"]}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Example"}),": Robot walking to office when human blocks path"]}),"\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"Original path: [0,0] \u2192 [10, 0] \u2192 [10, 5] \u2192 [20, 5]"}),"\n",(0,s.jsx)(e.li,{children:"Obstacle detected at [10, 0]"}),"\n",(0,s.jsx)(e.li,{children:"Replanning: [0, 0] \u2192 [5, 3] \u2192 [10, 5] \u2192 [20, 5] (6-second computation)"}),"\n",(0,s.jsx)(e.li,{children:"Continue walking on new path (only minor deviation)"}),"\n"]}),"\n",(0,s.jsx)(e.h3,{id:"energy-efficient-locomotion",children:"Energy-Efficient Locomotion"}),"\n",(0,s.jsx)(e.p,{children:"Different walking speeds have different energy costs:"}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{children:"Energy Cost (J/meter)\r\n    \u2502\r\n 50 \u2502      \u2571\u2572\r\n    \u2502     \u2571  \u2572\r\n 40 \u2502    \u2571    \u2572\r\n    \u2502   \u2571      \u2572    Optimal speed\r\n 30 \u2502  \u2571        \u2572   1.2 m/s\r\n    \u2502 \u2571          \u2572\r\n 20 \u2502\u2571            \u2572\r\n    \u2502              \u2572\r\n 10 \u2502               \u2572___\r\n    \u2502\r\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Speed (m/s)\r\n    0  0.5  1.0  1.5  2.0  2.5  3.0\n"})}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Optimization"}),": For long-distance navigation, walk at optimal speed"]}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Too slow: Inefficient (high per-meter cost)"}),"\n",(0,s.jsx)(e.li,{children:"Too fast: Inefficient (muscular effort increases exponentially)"}),"\n",(0,s.jsx)(e.li,{children:"Optimal: ~1.2-1.5 m/s for most humanoids"}),"\n"]}),"\n",(0,s.jsxs)(e.p,{children:[(0,s.jsx)(e.strong,{children:"Trajectory optimization"})," ensures minimal acceleration (also wastes energy)"]})]})}function h(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>o,x:()=>l});var r=i(6540);const s={},t=r.createContext(s);function o(n){const e=r.useContext(t);return r.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:o(n.components),r.createElement(t.Provider,{value:e},n.children)}}}]);